% vim: set ft=prolog:

% Neste arquivo est√£o especificados os predicados que devem ser implementados.
% Voc√™ pode criar predicados auxiliares quando necess√°rio.
%
% No arquivo resame_testes.pl est√£o os testes para alguns predicados.
%
% Para implementar cada predicado, primeiro voc√™ deve ler e entender a
% especifica√ß√£o e o teste.
%
% A especifica√ß√£o dos par√¢metros dos predicados segue o formato descrito em
% http://www.swi-prolog.org/pldoc/doc_for?object=section%282,%274.1%27,swi%28%27/doc/Manual/preddesc.html%27%29%29
%
% Um Jogo same √© representado por uma lista de colunas, sem os elementos nulos
% (zeros).
% Por exemplo, o jogo
% 2 | 3 0 0 0
% 1 | 2 2 2 0
% 0 | 2 3 3 1
% --+--------
%   | 0 1 2 3
% √© representado como [[2, 2, 3], [3, 2], [3, 2], [1]].
% O tamanho deste jogo √© 3x4 (linhas x colunas).
%
% Uma posi√ß√£o no jogo √© representado por uma estrutura pos com dois argumentos
% (lin, col), onde lin √© o n√∫mero da linha e col √© o n√∫mero da coluna.  No
% exemplo anterior, a posi√ß√£o pos(0, 1) tem cor 3, e a posi√ß√£o pos(1, 2) tem
% cor 2.

% Voc√™ pode utilizar os predicados definidos no arquivo resame_utils.pl
:- consult(resame_utils).

%% main(+File) is det
%
%  Carrega um jogo same do arquivo File e imprime uma resolu√ß√£o na sa√≠da padr√£o
%  ou sem-solucao se o jogo n√£o tem solu√ß√£o.

main(File) :-
    read_matriz_file(File, M),
    transpose(M, Same),
    solve(Same, Moves).
    writeln(Moves).

%% solve(+Same, -Moves) is nondet
%
%  Verdadeiro se Moves √© uma sequ√™ncia de jogadas (lista de posi√ß√µes) que
%  quando realizadas ("clicadas") resolvem o jogo Same.
%  Este predicado n√£o tem teste de unidade. Ele √© testado pelo testador.

solve([], []).
solve(Same, [M|Moves]) :-
    group(Same, Group),
    remove_group(Same, Group, NewSame),
    [M|_] = Group,
    solve(NewSame, Moves).

%% group(+Same, ?Group) is nondet
%
%  Verdadeiro se Group √© um grupo de Same. Group √© uma lista de posi√ß√µes
%  (estrutura pos(lin,col)). Este predicado √© n√£o determin√≠stico e deve ser
%  capaz de gerar todos os grupos de Same. Este predicado n√£o deve gerar grupos
%  repetidos. Este predicado e group/3 para v√£o utilizar os mesmos precicados
%  auxiliares.

group(Same, Group) :-
    color(Same, pos(X, Y), Color),
    group(Same, pos(X, Y), NewGroup),
    zero_group(Same, Group, NewSame),
    length(NewGroup, NumPosGroup),
    NumPosGroup > 1,
    Group = NewGroup.

zero_group(Same, [], Same).

zero_group(Same, [pos(Col, Row) | T], NewSame) :-
    nth0(Col, Same, Column),
    nth0(Row, Column, _, Other),
    nth0(Row, OtherColumn, 0, NewColumn),
    nth0(Col, Same, _, OtherSame),
    nth0(Col, OtherSame, NewColumn, AnotherSame),
    zero_group(AnotherSame, T, NewSame), !.

%% grupo(+Same, +P, -Group) is semidet
%
%  Verdadeiro se Group √© um grupo de Same que cont√©m a posi√ß√£o P.

group(Same, P, Group) :-
    Vs = [P],
    nhood(Same,Vs,Vs,SubGroup),
    SubGroup \== [],
    append(Vs,SubGroup,Group).
    
nhood(_, [], _, []).

nhood(Same,[P|T],Vs,Group) :-
    same_color_neighbors_list(Same,P,Vs,Ns),
    append(Vs,Ns,NewVs),    
    append(T,Ns,NewT),
    nhood(Same,NewT,NewVs,SubGroup),
    append(Ns,SubGroup,Group).

same_color_neighbors(Same,P,N) :-
    neighbors(P,N),
    color(Same,P,C),
    color(Same,N,C).

same_color_neighbors_list(Same,P,Vs,Ns) :-
    findall(N,(same_color_neighbors(Same,P,N),\+member(N,Vs)), Ns).  

color(Same,pos(X,Y),Color) :-
    nth0(Y,Same,Column),
    nth0(X, Column, _, OtherColumn).

%left right
neighbors(pos(X0,Y0), pos(X1,Y1)):-
    neighborsXY(X0,X1),
    Y0 = Y1.

%up down
neighbors(pos(X0,Y0),pos(X1,Y1)):-
    X0 = X1,    
    neighborsXY(Y0,Y1).    

neighborsXY(C0,C1):-
    C1 is C0 -1; %down and left
    C1 is C0 +1. %up and right

%% remove_group(+Same, +Group, -NewSame) is semidet
%
%  Verdadeiro se NewSame √© obtido de Same removendo os elemento especificados
%  em Group. A remo√ß√£o √© feita de acordo com as regras do jogo same.
%  Dica:
%    - crie um predicado auxiliar remove_column_group, que remove os elementos
%    de uma coluna espec√≠fica

remove_group(Same, Group, NewSame) :-
    length(Same, SameSize),
    NumCol is SameSize - 1,
    remove_column_group(Same, NumCol, Group, NSame),
    reverse(NSame, NewSame).

%% remove_column_group(+Same, +Column, +Group, -NewSame) is semidet
%
%  Verdadeiro se NewSame È obtido de Same removendo os elementos
%  especificados em Group e que est„o na Column.

remove_column_group(Same, -1, _, []).

remove_column_group(Same, Col, Group, NewSame) :-
    findall(X, member(pos(X, Col),  Group), ListRow),
    nth0(Col, Same, Column),
    remove_rows_column(Column, ListRow, NewColumn),
    NewColumn = [],
    NextCol is Col -1,
    remove_column_group(Same, Nextcol, Group, NewSame), !.

remove_column_group(Same, Col, Group, [HeadColumn | RestColumn]) :-
    findall(X, member(pos(X, Col), Group), ListRow),
    nth0(Col, Same, Column),
    remove_rows_column(Column, ListRow, NewColumn),
    NewColumn \= [],
    [HeadColumn | _] = [NewColumn],
    NextCol is Col - 1,
    remove_column_group(Same, NextCol, Group, RestColumn), !.

%% remove_rows_column(+Column, +Rows, -NewColumn) is semidet
%
%  Verdadeiro se NewColumn È obtido de Column removendo os elementos
%  de Rows.

remove_rows_column(Column, [], Column).

remove_rows_column(Column, [Row | Rest], NewColumn) :-
    nth0(Row, Column, _, OtherColumn),
    remove_rows_column(OtherColumn, Rest, NewColumn), !.


